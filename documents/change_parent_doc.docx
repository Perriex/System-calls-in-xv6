change parent id document

in  file proc.h_________________add new variable for trace________________________
#line 38
struct proc {
  uint sz;                     // Size of process memory (bytes)
  pde_t* pgdir;                // Page table
  char *kstack;                // Bottom of kernel stack for this process
  enum procstate state;        // Process state
  int pid;                     // Process ID
  struct proc *parent;         // Parent process
  struct proc *trace_parent;   // Parent debug process - equal to parent after fork
  struct trapframe *tf;        // Trap frame for current syscall
  struct context *context;     // swtch() here to run process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};

in proc.c _________________function to get proc by id and initial trace parent in fork and actual function for trace parent________________________

// get proc by id  
#line 24
struct proc * getprocbypid(int _pid)
{
  struct proc *p;
  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
    if (p->pid == _pid)
      return p;
}

#line 193
int fork(void) 
{
  int i, pid;
  struct proc *np;
  struct proc *curproc = myproc();

  // Allocate process.
  if ((np = allocproc()) == 0)
  {
    return -1;
  }

  // Copy process state from proc.
  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
  {
    kfree(np->kstack);
    np->kstack = 0;
    np->state = UNUSED;
    return -1;
  }
  np->sz = curproc->sz;
  np->parent = curproc;
  np->trace_parent = curproc;
  *np->tf = *curproc->tf;

  // Clear %eax so that fork returns 0 in the child.
  np->tf->eax = 0;

  for (i = 0; i < NOFILE; i++)
    if (curproc->ofile[i])
      np->ofile[i] = filedup(curproc->ofile[i]);
  np->cwd = idup(curproc->cwd);

  safestrcpy(np->name, curproc->name, sizeof(curproc->name));

  pid = np->pid;

  acquire(&ptable.lock);

  np->state = RUNNABLE;

  release(&ptable.lock);

  return pid;
}

#line 557
void setprocparent(int pid)
{
  struct proc *curproc = myproc();
  struct proc *childproc = getprocbypid(pid); 

  childproc->trace_parent = curproc;
}

in defs.h _____________________add interface of function_____________________
#line 104
//PAGEBREAK: 16
// proc.c
struct proc*    getprocbypid(int);



and in sysproc_________________add system call for change parent________________________
#line 93
int sys_setprocparent(void){
  int pid;

  if(argint(0, &pid) < 0)
    return -1;
  
  setprocparent(pid);
  return 0;
}


in syscall.h _______________add code for syscall_____________________________
#line 25
#define SYS_setprocparent 24


in syscall.c ____________________add interface of syscall and map to code________________________
#line 106
extern int sys_setprocparent(void);
#line 130
[SYS_setprocparent] sys_setprocparent,

in user.h ________________interface of function in system call______________________________
#line 26
void setprocparent(int); // new 

in usys.S___________________add system call to assembly___________________________
#line 32
SYSCALL(setprocparent)
